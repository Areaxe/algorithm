<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>广度搜索</title>
    <style>
        #canvas {
            background-color: #f0f0f0;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="800" height="800" />
</body>
<script>
    let grid_width = 5; // 一个结点的宽度
    let canvas = document.getElementById('canvas')
    let ctx = canvas.getContext('2d');
    let originColor = 'darkgreen'; // 搜索源点颜色
    let targetColor = 'lightgreen'; // 被搜索点颜色
    let visitedColor = 'green'; // 已经遍历过的点的元素
    let dataWidth = 150;  // 画板矩阵一行或者一列的点数
    let landSize = 60;  // 源点个数

    // 0表示待搜索的点，1表示源点，用2 表示已经访问过的点
    window.onload = function () {
        // 初始化数据
        let grid = Array.from({ length: dataWidth }, () => Array.from({ length: dataWidth }, () => 0))
        for (let i = 0; i < landSize; i++) {
            let randomx = parseInt(Math.random() * dataWidth)
            let randomy = parseInt(Math.random() * dataWidth)
            //  生成源点
            grid[randomx][randomy] = 1;
        }
        
        renderGrid(grid)
        wideSearch(grid)
    }
    function wideSearch (grid) {
        // let distance = -1;
        let queen = [];  // 待搜索队列
        let searchWidth = grid.length; // 搜索范围
        // 源点入队
        for (let i = 0; i < searchWidth; i++) {
            for (let j = 0; j < searchWidth; j++) {
                if (grid[i][j]) {
                    queen.push([i, j])
                }
            }
        }
        if (!queen.length || queen.length === searchWidth * searchWidth) {
            return -1;
        }

        let timer = setInterval(function () {
            // 如果队列有结点
            if (queen.length) {
                let pointLen = queen.length;
                // distance++;
                for (let i = 0; i < pointLen; i++) {
                    let position = queen.shift();
                    let x = position[0];  // 被搜索结点的横坐标
                    let y = position[1];  // 被搜索结点的纵坐标
                    // 向左搜索
                    if (x > 0 && grid[x - 1][y] === 0) {
                        queen.push([x - 1, y])
                        grid[x - 1][y] = 2;
                    }
                    //向右搜索
                    if (x < searchWidth - 1 && grid[x + 1][y] === 0) {
                        queen.push([x + 1, y])
                        grid[x + 1][y] = 2;
                    }
                    //向下搜索
                    if (y < searchWidth - 1 && grid[x][y + 1] === 0) {
                        queen.push([x, y + 1])
                        grid[x][y + 1] = 2;
                    }
                    //向上搜索
                    if (y > 0 && grid[x][y - 1] === 0) {
                        queen.push([x, y - 1])
                        grid[x][y - 1] = 2;
                    }
                }
                // 渲染
                renderGrid(grid)
            }else{
                clearInterval(timer)
            }
        }, 50)
    };

    // 渲染表格
    function renderGrid(grid) {
        let len = grid.length;

        for (let i = 0; i < len; i++) {
            for (let j = 0; j < len; j++) {
                ctx.beginPath();
                ctx.moveTo(j * grid_width, i * grid_width);
                ctx.rect(j * grid_width, i * grid_width, grid_width, grid_width);
                //不同颜色区分源点、被访问过的点、待访问的点
                if (grid[i][j] === 0) {
                    ctx.fillStyle = targetColor;
                } else if (grid[i][j] === 1) {
                    ctx.fillStyle = originColor;
                } else {
                    ctx.fillStyle = visitedColor;
                }
                ctx.fill()
                ctx.save()
            }
        }
    }
</script>

</html>